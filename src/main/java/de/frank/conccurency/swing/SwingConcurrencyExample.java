package de.frank.conccurency.swing;

import javax.swing.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ExecutionException;

public class SwingConcurrencyExample {
    /*
    The Swing framework is essentially single threaded, as are most GUI toolkits. The main thread which updates the UI
    is called the Event Dispatch Thread (EDT). All the graphical components are created by this thread, all the action,
    event, etc. listeners run in this thread. So if your code performs a long running/time consuming or blocking task in the EDT,
    then the Swing UI will become frozen until your code is done.
     */
    /*
    You have to create a subclass of SwingWorker and launch it by calling execute(); this will probably happen in an
    ActionListener in your Swing code. Calling execute() submits this SwingWorker task to the threadpool that Swing
    keeps for running background tasks. The execute() method returns immediately; so your calling thread (which may be
    the EDT itself) will continue.
    Put the code for the background task in T doInBackground(). This is the code that performs the time consuming
    one-shot task. If exceptions are generated here, they can be caught by a call to T get(), so can the return value.
    Once this method completes (on the background thread), done() will be called on the EDT. The return value is of
    type “” - this is whatever class you decide to make the doInBackground() method return. “” is the result type
    returned by this SwingWorker’s doInBackground and get methods. You can either implement this time consuming task in
    this method, or you can call an external web service, or other gateway or proxy class to request something.
    The done() method is called on the EDT when your doInBackground() method exits (by returning a value or throwing an
    exception). In the done() method, you can retrieve the thrown exception or return value by calling get(). In this
    method, you have to perform whatever GUI updates, or interactions that are necessary with the return value or
    exceptions generated by the call to get().
    In this case the thread is started by calling execute() on the SwingWorker task itself. This submits the task to a
    threadpool of background threads that Swing manages, and the task will be executed in one of these threads.
    Please make sure that the task is easily interruptible - there is no way to preemptively interrupt/stop a thread in
    Java, only cooperative cancellation is possible.
    So, if you are performing any wait operations (waiting on a lock or monitor) make sure to catch the
    InterruptedException and cancel out of the task.
    If you are performing blocking IO, make sure to catch IOException, to cancel out of it. The underlying stream that
    this task is blocking on has to be closed. Presumably, the object calling cancel(true) on your SwingWorker task
    will also have to call close() on the underlying Input/OutputStream in order for this to work. If you are unblocked
    due to to an IOException, you can always check for isCancelled() on the SwingWorker to see if it’s been cancelled.
    Also, make sure to check isCancelled() on the SwingWorker thread to see if the task has been cancelled, to end your
    task.
    If you don’t know what to do with the InterruptedException (if one is thrown), and if you catch it, make sure to
    call Thread.currentThread().interrupt() to maintain the interrupted flag, so that the executor running this thread
    will know what to do with the interruption. More on preserving thread interrupted state (if you don’t know what to
    do with the caught InterruptedException is explained here).
     */

    public static void main(String[] args) {

        SwingUtilities.invokeLater(() -> {
            initUI(5, 1000);
        });
    }

    private static void initUI(int steps, long millisecondsPerStep) {
        JTextArea textArea = new JTextArea();
        final JProgressBar progressBar = new JProgressBar(0, 100);
        SomeLongRunningTask task = new SomeLongRunningTask(textArea, steps, millisecondsPerStep);
        task.addPropertyChangeListener(
                new PropertyChangeListener() {
                    public void propertyChange(PropertyChangeEvent evt) {
                        if ("progress".equals(evt.getPropertyName())) {
                            progressBar.setValue((Integer) evt.getNewValue());
                        }
                    }
                });

        task.execute();
        textArea.setVisible(true);
        try {
            System.out.println(task.get()); //prints all prime numbers we have go
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }

    static class SomeLongRunningTask extends
            SwingWorker<List<String>, String> {
        private final int steps;
        private final long timePerStepInMs;
        private final JTextArea displayResultHere;
        private AbstractAction startButton;

        SomeLongRunningTask(JTextArea displayResultHere, int steps, long timePerStepInMs) {
            this.displayResultHere = displayResultHere;
            this.steps = steps;
            this.timePerStepInMs = timePerStepInMs;
        }

        /**
         * Computes a result, or throws an exception if unable to do so.
         * IMPORTANT: this method is executed in a (swing) background thread, managed by swing
         *
         * @return the result (which will be be automatically forwarded to EventDispatchThread via {@link #process(List)}
         */
        @Override
        public List<String> doInBackground() {
            List<String> results = new ArrayList<>();
            for (int step = 0; step < steps; step++) {
                if (isCancelled()) {
                    //we dont want partial results
                    return Collections.emptyList();
                }
                String stepResult = execStep(step, timePerStepInMs);
                results.add(stepResult);
                publish(stepResult);//(optional) publish intermediate processing results
                setProgress(100 * step / steps);
            }

            return results;
        }

        private static String execStep(int step, long timePerStepInMs) {
            //simulate a long running task
            simulateComputationHeavyTask(timePerStepInMs);
            return "Step_" + step + "_Mock_Result";
        }

        @SuppressWarnings("java:S2925")//explicitly want to use Thread.sleep
        private static void simulateComputationHeavyTask(long timePerStepInMs) {
            try {
                Thread.sleep(timePerStepInMs);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();//restore interrupted flag
            }
        }

        /**
         * Receives data chunks from the publish method asynchronously on the Event Dispatch Thread.
         * Should have been named "update UI" in EDT
         *
         * @param chunks
         */
        @Override
        protected void process(List<String> chunks) {
            //process
            for (String result : chunks) {
                displayResultHere.append(result + "\n");
            }
        }

        /**
         * Another option to automatically invoke a task (@EDT) is to use done
         */
        @Override
        protected void done() {
            startButton.setEnabled(true);
            //setCursor(null); //turn off the wait cursor
            displayResultHere.append("Done!\n");
        }
    }


}
